---
title: "Error Handling Patterns: Complete Guide"
description: "Master error handling patterns. Exception handling, error recovery, logging, and best practices for robust applications."
author: "TechDevDex Team"
date: "2024-12-11"
category: "Tutorial"
tags: ["Error Handling", "Exceptions", "Recovery", "Logging", "Programming"]
readTime: "24 min"
featured: false
rating: 5
featuredImage: "/images/tutorials/programming-tips/error-handling.jpg"
---

# Error Handling Patterns: Complete Guide

Learn how to handle errors effectively. From basic exception handling to advanced error recovery patterns and best practices.

## Error Handling Fundamentals

### Understanding Error Types

```python
# Error Types and Classification
class ErrorClassifier:
    """Classify and handle different types of errors"""
    
    def __init__(self):
        self.error_types = {
            "syntax_errors": "Code syntax issues",
            "runtime_errors": "Errors during execution",
            "logical_errors": "Incorrect program logic",
            "system_errors": "Operating system issues",
            "network_errors": "Network connectivity issues",
            "data_errors": "Invalid or corrupted data"
        }
    
    def classify_error(self, error):
        """Classify an error into appropriate category"""
        error_name = type(error).__name__
        
        if "SyntaxError" in error_name:
            return "syntax_errors"
        elif "RuntimeError" in error_name:
            return "runtime_errors"
        elif "ValueError" in error_name:
            return "logical_errors"
        elif "OSError" in error_name:
            return "system_errors"
        elif "ConnectionError" in error_name:
            return "network_errors"
        else:
            return "unknown"
    
    def get_error_severity(self, error):
        """Determine error severity level"""
        critical_errors = ["SystemExit", "KeyboardInterrupt", "MemoryError"]
        high_errors = ["RuntimeError", "OSError", "ConnectionError"]
        medium_errors = ["ValueError", "TypeError", "AttributeError"]
        low_errors = ["Warning", "DeprecationWarning"]
        
        error_name = type(error).__name__
        
        if error_name in critical_errors:
            return "critical"
        elif error_name in high_errors:
            return "high"
        elif error_name in medium_errors:
            return "medium"
        elif error_name in low_errors:
            return "low"
        else:
            return "unknown"

# Usage
classifier = ErrorClassifier()

try:
    # Some operation that might fail
    result = 10 / 0
except Exception as e:
    error_type = classifier.classify_error(e)
    severity = classifier.get_error_severity(e)
    print(f"Error type: {error_type}, Severity: {severity}")
```

### Basic Exception Handling

```python
# Basic Exception Handling Patterns
class BasicErrorHandler:
    """Basic error handling patterns and techniques"""
    
    def __init__(self):
        self.error_log = []
    
    def try_except_basic(self, func, *args, **kwargs):
        """Basic try-except pattern"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Error occurred: {e}")
            return None
    
    def try_except_specific(self, func, *args, **kwargs):
        """Specific exception handling"""
        try:
            return func(*args, **kwargs)
        except ValueError as e:
            print(f"Value error: {e}")
            return None
        except TypeError as e:
            print(f"Type error: {e}")
            return None
        except Exception as e:
            print(f"Unexpected error: {e}")
            return None
    
    def try_except_else_finally(self, func, *args, **kwargs):
        """Try-except-else-finally pattern"""
        try:
            result = func(*args, **kwargs)
        except Exception as e:
            print(f"Error occurred: {e}")
            result = None
        else:
            print("Operation completed successfully")
        finally:
            print("Cleanup operations")
        
        return result
    
    def handle_multiple_exceptions(self, func, *args, **kwargs):
        """Handle multiple exceptions in one block"""
        try:
            return func(*args, **kwargs)
        except (ValueError, TypeError, AttributeError) as e:
            print(f"Data error: {e}")
            return None
        except (OSError, IOError) as e:
            print(f"System error: {e}")
            return None
        except Exception as e:
            print(f"Unexpected error: {e}")
            return None

# Usage
handler = BasicErrorHandler()

def risky_operation(x, y):
    """Operation that might fail"""
    return x / y

# Test different error handling patterns
result1 = handler.try_except_basic(risky_operation, 10, 0)
result2 = handler.try_except_specific(risky_operation, 10, 0)
result3 = handler.try_except_else_finally(risky_operation, 10, 2)
```

## Advanced Error Handling Patterns

### Custom Exception Classes

```python
# Custom Exception Classes
class ApplicationError(Exception):
    """Base exception for application errors"""
    def __init__(self, message, error_code=None, details=None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code
        self.details = details or {}
    
    def __str__(self):
        return f"{self.error_code}: {self.message}" if self.error_code else self.message

class ValidationError(ApplicationError):
    """Exception for validation errors"""
    def __init__(self, message, field=None, value=None):
        super().__init__(message, error_code="VALIDATION_ERROR")
        self.field = field
        self.value = value

class BusinessLogicError(ApplicationError):
    """Exception for business logic errors"""
    def __init__(self, message, operation=None):
        super().__init__(message, error_code="BUSINESS_LOGIC_ERROR")
        self.operation = operation

class ExternalServiceError(ApplicationError):
    """Exception for external service errors"""
    def __init__(self, message, service=None, status_code=None):
        super().__init__(message, error_code="EXTERNAL_SERVICE_ERROR")
        self.service = service
        self.status_code = status_code

# Usage
def validate_user_data(user_data):
    """Validate user data with custom exceptions"""
    if not user_data.get("email"):
        raise ValidationError("Email is required", field="email")
    
    if not user_data.get("age") or user_data["age"] < 0:
        raise ValidationError("Age must be positive", field="age", value=user_data.get("age"))
    
    if user_data.get("age") < 18:
        raise BusinessLogicError("User must be at least 18 years old", operation="user_registration")

def call_external_service(service_url):
    """Call external service with custom exceptions"""
    try:
        # Simulate external service call
        response = {"status": 500, "message": "Internal server error"}
        if response["status"] != 200:
            raise ExternalServiceError(
                f"Service returned status {response['status']}",
                service=service_url,
                status_code=response["status"]
            )
    except ExternalServiceError:
        raise
    except Exception as e:
        raise ExternalServiceError(f"Unexpected error: {e}", service=service_url)
```

### Error Recovery Patterns

```python
# Error Recovery Patterns
class ErrorRecovery:
    """Error recovery patterns and strategies"""
    
    def __init__(self):
        self.retry_count = 0
        self.max_retries = 3
    
    def retry_pattern(self, func, *args, **kwargs):
        """Retry pattern for transient errors"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                print(f"Attempt {attempt + 1} failed: {e}")
                
                if attempt < self.max_retries - 1:
                    # Wait before retry
                    import time
                    time.sleep(2 ** attempt)  # Exponential backoff
                else:
                    print("All retry attempts failed")
        
        raise last_exception
    
    def circuit_breaker_pattern(self, func, *args, **kwargs):
        """Circuit breaker pattern for failing services"""
        if self._is_circuit_open():
            raise Exception("Circuit breaker is open")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def fallback_pattern(self, primary_func, fallback_func, *args, **kwargs):
        """Fallback pattern for service failures"""
        try:
            return primary_func(*args, **kwargs)
        except Exception as e:
            print(f"Primary function failed: {e}")
            print("Using fallback function")
            return fallback_func(*args, **kwargs)
    
    def timeout_pattern(self, func, timeout_seconds, *args, **kwargs):
        """Timeout pattern for long-running operations"""
        import signal
        
        def timeout_handler(signum, frame):
            raise TimeoutError("Operation timed out")
        
        # Set timeout
        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(timeout_seconds)
        
        try:
            result = func(*args, **kwargs)
            signal.alarm(0)  # Cancel timeout
            return result
        except TimeoutError:
            signal.alarm(0)  # Cancel timeout
            raise
        except Exception as e:
            signal.alarm(0)  # Cancel timeout
            raise e
    
    def _is_circuit_open(self):
        """Check if circuit breaker is open"""
        # Simplified implementation
        return False
    
    def _on_success(self):
        """Handle successful operation"""
        self.retry_count = 0
    
    def _on_failure(self):
        """Handle failed operation"""
        self.retry_count += 1

# Usage
recovery = ErrorRecovery()

def unreliable_service():
    """Service that might fail"""
    import random
    if random.random() < 0.7:  # 70% chance of failure
        raise ConnectionError("Service unavailable")
    return "Service response"

def fallback_service():
    """Fallback service"""
    return "Fallback response"

# Test retry pattern
try:
    result = recovery.retry_pattern(unreliable_service)
    print(f"Service result: {result}")
except Exception as e:
    print(f"Service failed after retries: {e}")

# Test fallback pattern
result = recovery.fallback_pattern(unreliable_service, fallback_service)
print(f"Final result: {result}")
```

### Error Logging and Monitoring

```python
# Error Logging and Monitoring
import logging
import json
from datetime import datetime
from typing import Dict, Any

class ErrorLogger:
    """Comprehensive error logging and monitoring"""
    
    def __init__(self, log_file="errors.log"):
        self.logger = self._setup_logger(log_file)
        self.error_stats = {}
    
    def _setup_logger(self, log_file):
        """Setup error logger"""
        logger = logging.getLogger("error_logger")
        logger.setLevel(logging.ERROR)
        
        # File handler
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.ERROR)
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.ERROR)
        
        # Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger
    
    def log_error(self, error, context=None, severity="error"):
        """Log error with context"""
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "error_type": type(error).__name__,
            "error_message": str(error),
            "severity": severity,
            "context": context or {},
            "stack_trace": self._get_stack_trace()
        }
        
        # Log to file
        self.logger.error(json.dumps(error_info, indent=2))
        
        # Update statistics
        self._update_error_stats(error_info)
        
        return error_info
    
    def log_error_with_recovery(self, error, recovery_action, context=None):
        """Log error with recovery action"""
        error_info = self.log_error(error, context)
        error_info["recovery_action"] = recovery_action
        
        # Log recovery attempt
        self.logger.info(f"Recovery action: {recovery_action}")
        
        return error_info
    
    def get_error_statistics(self):
        """Get error statistics"""
        return {
            "total_errors": sum(self.error_stats.values()),
            "error_types": self.error_stats,
            "most_common_error": max(self.error_stats.items(), key=lambda x: x[1]) if self.error_stats else None
        }
    
    def _get_stack_trace(self):
        """Get stack trace for error"""
        import traceback
        return traceback.format_exc()
    
    def _update_error_stats(self, error_info):
        """Update error statistics"""
        error_type = error_info["error_type"]
        self.error_stats[error_type] = self.error_stats.get(error_type, 0) + 1

# Usage
error_logger = ErrorLogger()

def risky_operation_with_logging():
    """Operation with error logging"""
    try:
        # Some risky operation
        result = 10 / 0
        return result
    except Exception as e:
        error_logger.log_error(
            e,
            context={"operation": "risky_operation", "input": "10/0"},
            severity="high"
        )
        raise

# Test error logging
try:
    risky_operation_with_logging()
except Exception as e:
    print(f"Error logged: {e}")

# Get error statistics
stats = error_logger.get_error_statistics()
print(f"Error statistics: {stats}")
```

## Error Handling Best Practices

### Defensive Programming

```python
# Defensive Programming Patterns
class DefensiveProgramming:
    """Defensive programming techniques for error prevention"""
    
    def __init__(self):
        self.validation_rules = {}
    
    def validate_input(self, data, rules):
        """Validate input data"""
        errors = []
        
        for field, rule in rules.items():
            if field not in data:
                errors.append(f"Missing required field: {field}")
                continue
            
            value = data[field]
            
            if "type" in rule and not isinstance(value, rule["type"]):
                errors.append(f"Field {field} must be of type {rule['type'].__name__}")
            
            if "min_length" in rule and len(str(value)) < rule["min_length"]:
                errors.append(f"Field {field} is too short")
            
            if "max_length" in rule and len(str(value)) > rule["max_length"]:
                errors.append(f"Field {field} is too long")
            
            if "pattern" in rule and not rule["pattern"].match(str(value)):
                errors.append(f"Field {field} does not match required pattern")
        
        if errors:
            raise ValidationError("; ".join(errors))
        
        return True
    
    def safe_divide(self, a, b, default=0):
        """Safe division with default value"""
        try:
            return a / b
        except ZeroDivisionError:
            return default
        except TypeError:
            return default
    
    def safe_get(self, data, key, default=None):
        """Safe dictionary access"""
        try:
            return data[key]
        except (KeyError, TypeError):
            return default
    
    def safe_call(self, func, *args, **kwargs):
        """Safe function call with error handling"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Function {func.__name__} failed: {e}")
            return None
    
    def safe_file_operation(self, file_path, operation, default=None):
        """Safe file operations"""
        try:
            with open(file_path, 'r') as file:
                return operation(file)
        except FileNotFoundError:
            print(f"File not found: {file_path}")
            return default
        except PermissionError:
            print(f"Permission denied: {file_path}")
            return default
        except Exception as e:
            print(f"File operation failed: {e}")
            return default

# Usage
defensive = DefensiveProgramming()

# Test input validation
user_data = {"name": "John", "age": 25, "email": "john@example.com"}
validation_rules = {
    "name": {"type": str, "min_length": 2},
    "age": {"type": int, "min_length": 1},
    "email": {"type": str, "pattern": __import__("re").compile(r"^[^@]+@[^@]+\.[^@]+$")}
}

try:
    defensive.validate_input(user_data, validation_rules)
    print("Validation passed")
except ValidationError as e:
    print(f"Validation failed: {e}")

# Test safe operations
result1 = defensive.safe_divide(10, 0, default=0)
result2 = defensive.safe_get({"key": "value"}, "missing_key", default="default")
print(f"Safe division: {result1}")
print(f"Safe get: {result2}")
```

### Error Handling Strategies

```python
# Error Handling Strategies
class ErrorHandlingStrategies:
    """Different error handling strategies"""
    
    def __init__(self):
        self.error_handlers = {}
    
    def register_error_handler(self, error_type, handler):
        """Register error handler for specific error type"""
        self.error_handlers[error_type] = handler
    
    def handle_error(self, error, context=None):
        """Handle error using registered handlers"""
        error_type = type(error).__name__
        
        if error_type in self.error_handlers:
            return self.error_handlers[error_type](error, context)
        else:
            return self._default_error_handler(error, context)
    
    def _default_error_handler(self, error, context):
        """Default error handler"""
        print(f"Unhandled error: {error}")
        return None
    
    def fail_fast_strategy(self, func, *args, **kwargs):
        """Fail fast strategy - stop on first error"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Failing fast due to: {e}")
            raise
    
    def fail_safe_strategy(self, func, *args, **kwargs):
        """Fail safe strategy - continue despite errors"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Error occurred but continuing: {e}")
            return None
    
    def graceful_degradation_strategy(self, func, fallback_func, *args, **kwargs):
        """Graceful degradation strategy"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Primary function failed, using fallback: {e}")
            return fallback_func(*args, **kwargs)
    
    def retry_with_backoff_strategy(self, func, max_retries=3, *args, **kwargs):
        """Retry with exponential backoff strategy"""
        import time
        
        for attempt in range(max_retries):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt
                    print(f"Attempt {attempt + 1} failed, retrying in {wait_time} seconds: {e}")
                    time.sleep(wait_time)
                else:
                    print(f"All retry attempts failed: {e}")
                    raise

# Usage
strategies = ErrorHandlingStrategies()

# Register error handlers
strategies.register_error_handler("ValueError", lambda e, ctx: print(f"Value error handled: {e}"))
strategies.register_error_handler("TypeError", lambda e, ctx: print(f"Type error handled: {e}"))

# Test different strategies
def test_function():
    """Test function that might fail"""
    import random
    if random.random() < 0.5:
        raise ValueError("Random error")
    return "Success"

# Test fail fast
try:
    strategies.fail_fast_strategy(test_function)
except Exception as e:
    print(f"Fail fast caught: {e}")

# Test fail safe
result = strategies.fail_safe_strategy(test_function)
print(f"Fail safe result: {result}")

# Test graceful degradation
def fallback_function():
    return "Fallback result"

result = strategies.graceful_degradation_strategy(test_function, fallback_function)
print(f"Graceful degradation result: {result}")
```

## Error Handling in Different Contexts

### Web Application Error Handling

```python
# Web Application Error Handling
from flask import Flask, jsonify, request
import logging

app = Flask(__name__)

class WebErrorHandler:
    """Error handling for web applications"""
    
    def __init__(self, app):
        self.app = app
        self.setup_error_handlers()
    
    def setup_error_handlers(self):
        """Setup error handlers for web application"""
        
        @self.app.errorhandler(400)
        def bad_request(error):
            return jsonify({
                "error": "Bad Request",
                "message": "The request could not be understood",
                "status_code": 400
            }), 400
        
        @self.app.errorhandler(404)
        def not_found(error):
            return jsonify({
                "error": "Not Found",
                "message": "The requested resource was not found",
                "status_code": 404
            }), 404
        
        @self.app.errorhandler(500)
        def internal_error(error):
            return jsonify({
                "error": "Internal Server Error",
                "message": "An unexpected error occurred",
                "status_code": 500
            }), 500
        
        @self.app.errorhandler(ValidationError)
        def validation_error(error):
            return jsonify({
                "error": "Validation Error",
                "message": str(error),
                "status_code": 400
            }), 400
        
        @self.app.errorhandler(BusinessLogicError)
        def business_logic_error(error):
            return jsonify({
                "error": "Business Logic Error",
                "message": str(error),
                "status_code": 422
            }), 422
    
    def handle_api_error(self, func):
        """Decorator for API error handling"""
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except ValidationError as e:
                return jsonify({"error": "Validation Error", "message": str(e)}), 400
            except BusinessLogicError as e:
                return jsonify({"error": "Business Logic Error", "message": str(e)}), 422
            except Exception as e:
                logging.error(f"Unexpected error: {e}")
                return jsonify({"error": "Internal Server Error", "message": "An unexpected error occurred"}), 500
        
        return wrapper

# Usage
web_handler = WebErrorHandler(app)

@app.route('/api/users', methods=['POST'])
@web_handler.handle_api_error
def create_user():
    """Create user with error handling"""
    data = request.get_json()
    
    if not data:
        raise ValidationError("Request body is required")
    
    if not data.get("email"):
        raise ValidationError("Email is required")
    
    if not data.get("age") or data["age"] < 18:
        raise BusinessLogicError("User must be at least 18 years old")
    
    # Create user logic here
    return jsonify({"message": "User created successfully"}), 201
```

### Database Error Handling

```python
# Database Error Handling
import sqlite3
from contextlib import contextmanager

class DatabaseErrorHandler:
    """Error handling for database operations"""
    
    def __init__(self, db_path):
        self.db_path = db_path
    
    @contextmanager
    def get_connection(self):
        """Get database connection with error handling"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            yield conn
        except sqlite3.Error as e:
            if conn:
                conn.rollback()
            raise DatabaseError(f"Database error: {e}")
        finally:
            if conn:
                conn.close()
    
    def safe_execute(self, query, params=None):
        """Safely execute database query"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params or ())
                conn.commit()
                return cursor.fetchall()
        except sqlite3.Error as e:
            raise DatabaseError(f"Query execution failed: {e}")
    
    def safe_transaction(self, operations):
        """Safely execute database transaction"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                
                for operation in operations:
                    cursor.execute(operation["query"], operation.get("params", ()))
                
                conn.commit()
                return True
        except sqlite3.Error as e:
            raise DatabaseError(f"Transaction failed: {e}")

class DatabaseError(Exception):
    """Custom exception for database errors"""
    pass

# Usage
db_handler = DatabaseErrorHandler("example.db")

# Test safe execution
try:
    result = db_handler.safe_execute("SELECT * FROM users WHERE id = ?", (1,))
    print(f"Query result: {result}")
except DatabaseError as e:
    print(f"Database error: {e}")

# Test safe transaction
operations = [
    {"query": "INSERT INTO users (name, email) VALUES (?, ?)", "params": ("John", "john@example.com")},
    {"query": "INSERT INTO users (name, email) VALUES (?, ?)", "params": ("Jane", "jane@example.com")}
]

try:
    db_handler.safe_transaction(operations)
    print("Transaction completed successfully")
except DatabaseError as e:
    print(f"Transaction failed: {e}")
```

## Conclusion

Effective error handling is crucial for building robust applications. By following these patterns and best practices, you can create applications that gracefully handle errors and provide better user experiences.

Remember to:
- Use appropriate error types
- Implement proper logging
- Plan for error recovery
- Follow defensive programming
- Test error scenarios
- Document error handling strategies

Happy coding! 🚀
