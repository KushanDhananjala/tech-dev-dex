---
title: "Python Email Automation: Complete Guide"
description: "Automate email workflows with Python. SMTP, IMAP, email parsing, scheduling, and advanced email automation patterns."
author: "TechDevDex Team"
date: "2024-12-13"
category: "Tutorial"
tags: ["Python", "Email", "Automation", "SMTP", "IMAP"]
readTime: "25 min"
featured: false
rating: 5
featuredImage: "/images/tutorials/python-automation/python-email-automation.svg"
---

# Python Email Automation: Complete Guide

Learn how to automate email workflows with Python. From sending emails to parsing and organizing your inbox.

## Essential Libraries

### Installation

```bash
# Core email libraries
pip install smtplib email
pip install imaplib

# Advanced email handling
pip install yagmail
pip install exchangelib
pip install python-dotenv

# Email parsing
pip install email-validator
pip install beautifulsoup4

# Scheduling
pip install schedule
pip install APScheduler
```

## Sending Emails

### Basic SMTP Email

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import os

def send_email(smtp_server, smtp_port, username, password, 
               to_email, subject, body, attachments=None):
    """Send email with attachments"""
    
    # Create message
    msg = MIMEMultipart()
    msg['From'] = username
    msg['To'] = to_email
    msg['Subject'] = subject
    
    # Add body
    msg.attach(MIMEText(body, 'plain'))
    
    # Add attachments
    if attachments:
        for file_path in attachments:
            if os.path.isfile(file_path):
                with open(file_path, "rb") as attachment:
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(attachment.read())
                
                encoders.encode_base64(part)
                part.add_header(
                    'Content-Disposition',
                    f'attachment; filename= {os.path.basename(file_path)}'
                )
                msg.attach(part)
    
    # Send email
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(username, password)
        text = msg.as_string()
        server.sendmail(username, to_email, text)
        server.quit()
        print("Email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")

# Usage
send_email(
    smtp_server='smtp.gmail.com',
    smtp_port=587,
    username='your-email@gmail.com',
    password='your-app-password',
    to_email='recipient@example.com',
    subject='Test Email',
    body='This is a test email from Python!',
    attachments=['document.pdf']
)
```

### HTML Email with Templates

```python
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib

def send_html_email(smtp_server, smtp_port, username, password,
                   to_email, subject, html_content):
    """Send HTML email"""
    
    msg = MIMEMultipart('alternative')
    msg['From'] = username
    msg['To'] = to_email
    msg['Subject'] = subject
    
    # Create HTML and text versions
    html_part = MIMEText(html_content, 'html')
    msg.attach(html_part)
    
    # Send email
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(username, password)
        server.sendmail(username, to_email, msg.as_string())
        server.quit()
        print("HTML email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")

# HTML template
html_template = """
<html>
<body>
    <h2>Welcome to Our Service!</h2>
    <p>Dear {name},</p>
    <p>Thank you for signing up. Here are your details:</p>
    <ul>
        <li>Email: {email}</li>
        <li>Plan: {plan}</li>
        <li>Start Date: {start_date}</li>
    </ul>
    <p>Best regards,<br>The Team</p>
</body>
</html>
"""

# Send personalized HTML email
def send_welcome_email(user_data):
    html_content = html_template.format(**user_data)
    send_html_email(
        smtp_server='smtp.gmail.com',
        smtp_port=587,
        username='your-email@gmail.com',
        password='your-app-password',
        to_email=user_data['email'],
        subject='Welcome to Our Service!',
        html_content=html_content
    )
```

### Using Yagmail for Simplicity

```python
import yagmail

def send_email_yagmail(to_email, subject, body, attachments=None):
    """Send email using yagmail"""
    
    # Initialize yagmail
    yag = yagmail.SMTP('your-email@gmail.com', 'your-app-password')
    
    # Send email
    yag.send(
        to=to_email,
        subject=subject,
        contents=body,
        attachments=attachments
    )
    
    print("Email sent successfully!")

# Usage
send_email_yagmail(
    to_email='recipient@example.com',
    subject='Test Email',
    body='This is a test email using yagmail!',
    attachments=['document.pdf']
)
```

## Reading Emails

### IMAP Email Reading

```python
import imaplib
import email
from email.header import decode_header

def read_emails(imap_server, username, password, folder='INBOX'):
    """Read emails from IMAP server"""
    
    # Connect to server
    mail = imaplib.IMAP4_SSL(imap_server)
    mail.login(username, password)
    mail.select(folder)
    
    # Search for emails
    status, messages = mail.search(None, 'ALL')
    email_ids = messages[0].split()
    
    emails = []
    
    for email_id in email_ids:
        # Fetch email
        status, msg_data = mail.fetch(email_id, '(RFC822)')
        
        # Parse email
        email_message = email.message_from_bytes(msg_data[0][1])
        
        # Extract information
        subject = decode_header(email_message["Subject"])[0][0]
        if isinstance(subject, bytes):
            subject = subject.decode()
        
        from_email = email_message.get("From")
        date = email_message.get("Date")
        
        # Get body
        body = ""
        if email_message.is_multipart():
            for part in email_message.walk():
                if part.get_content_type() == "text/plain":
                    body = part.get_payload(decode=True).decode()
                    break
        else:
            body = email_message.get_payload(decode=True).decode()
        
        emails.append({
            'id': email_id.decode(),
            'subject': subject,
            'from': from_email,
            'date': date,
            'body': body
        })
    
    mail.close()
    mail.logout()
    
    return emails

# Usage
emails = read_emails(
    imap_server='imap.gmail.com',
    username='your-email@gmail.com',
    password='your-app-password'
)

for email in emails:
    print(f"Subject: {email['subject']}")
    print(f"From: {email['from']}")
    print(f"Date: {email['date']}")
    print(f"Body: {email['body'][:100]}...")
    print("-" * 50)
```

### Email Filtering and Search

```python
def search_emails(imap_server, username, password, search_criteria):
    """Search emails with specific criteria"""
    
    mail = imaplib.IMAP4_SSL(imap_server)
    mail.login(username, password)
    mail.select('INBOX')
    
    # Search criteria
    status, messages = mail.search(None, search_criteria)
    email_ids = messages[0].split()
    
    emails = []
    
    for email_id in email_ids:
        status, msg_data = mail.fetch(email_id, '(RFC822)')
        email_message = email.message_from_bytes(msg_data[0][1])
        
        # Extract information
        subject = decode_header(email_message["Subject"])[0][0]
        if isinstance(subject, bytes):
            subject = subject.decode()
        
        from_email = email_message.get("From")
        date = email_message.get("Date")
        
        emails.append({
            'id': email_id.decode(),
            'subject': subject,
            'from': from_email,
            'date': date
        })
    
    mail.close()
    mail.logout()
    
    return emails

# Search examples
# Unread emails
unread_emails = search_emails(
    imap_server='imap.gmail.com',
    username='your-email@gmail.com',
    password='your-app-password',
    search_criteria='UNSEEN'
)

# Emails from specific sender
sender_emails = search_emails(
    imap_server='imap.gmail.com',
    username='your-email@gmail.com',
    password='your-app-password',
    search_criteria='FROM "noreply@example.com"'
)

# Emails with specific subject
subject_emails = search_emails(
    imap_server='imap.gmail.com',
    username='your-email@gmail.com',
    password='your-app-password',
    search_criteria='SUBJECT "Important"'
)
```

## Email Automation Workflows

### Automated Email Responses

```python
import re
from datetime import datetime

class EmailAutoResponder:
    def __init__(self, imap_server, smtp_server, username, password):
        self.imap_server = imap_server
        self.smtp_server = smtp_server
        self.username = username
        self.password = password
        self.processed_emails = set()
    
    def check_for_new_emails(self):
        """Check for new emails and process them"""
        mail = imaplib.IMAP4_SSL(self.imap_server)
        mail.login(self.username, self.password)
        mail.select('INBOX')
        
        # Search for unread emails
        status, messages = mail.search(None, 'UNSEEN')
        email_ids = messages[0].split()
        
        for email_id in email_ids:
            if email_id.decode() not in self.processed_emails:
                self.process_email(email_id, mail)
                self.processed_emails.add(email_id.decode())
        
        mail.close()
        mail.logout()
    
    def process_email(self, email_id, mail):
        """Process individual email"""
        status, msg_data = mail.fetch(email_id, '(RFC822)')
        email_message = email.message_from_bytes(msg_data[0][1])
        
        subject = decode_header(email_message["Subject"])[0][0]
        if isinstance(subject, bytes):
            subject = subject.decode()
        
        from_email = email_message.get("From")
        
        # Get body
        body = ""
        if email_message.is_multipart():
            for part in email_message.walk():
                if part.get_content_type() == "text/plain":
                    body = part.get_payload(decode=True).decode()
                    break
        else:
            body = email_message.get_payload(decode=True).decode()
        
        # Determine response
        response = self.generate_response(subject, body, from_email)
        
        if response:
            self.send_auto_response(from_email, response)
    
    def generate_response(self, subject, body, from_email):
        """Generate automated response based on email content"""
        
        # Check for keywords
        if 'support' in subject.lower() or 'help' in subject.lower():
            return "Thank you for contacting support. We'll get back to you within 24 hours."
        
        if 'order' in subject.lower():
            return "Thank you for your order. We'll process it shortly."
        
        if 'unsubscribe' in body.lower():
            return "You have been unsubscribed from our mailing list."
        
        # Check for specific patterns
        if re.search(r'\b(urgent|asap|immediately)\b', body.lower()):
            return "We've received your urgent request and will prioritize it."
        
        return None
    
    def send_auto_response(self, to_email, response):
        """Send automated response"""
        try:
            server = smtplib.SMTP(self.smtp_server, 587)
            server.starttls()
            server.login(self.username, self.password)
            
            msg = MIMEText(response)
            msg['From'] = self.username
            msg['To'] = to_email
            msg['Subject'] = 'Re: Automated Response'
            
            server.sendmail(self.username, to_email, msg.as_string())
            server.quit()
            
            print(f"Auto-response sent to {to_email}")
        except Exception as e:
            print(f"Error sending auto-response: {e}")

# Usage
responder = EmailAutoResponder(
    imap_server='imap.gmail.com',
    smtp_server='smtp.gmail.com',
    username='your-email@gmail.com',
    password='your-app-password'
)

# Check for new emails
responder.check_for_new_emails()
```

### Email Scheduling

```python
import schedule
import time
from datetime import datetime

class EmailScheduler:
    def __init__(self):
        self.scheduled_emails = []
    
    def schedule_email(self, to_email, subject, body, send_time):
        """Schedule an email to be sent at a specific time"""
        self.scheduled_emails.append({
            'to': to_email,
            'subject': subject,
            'body': body,
            'send_time': send_time
        })
    
    def send_scheduled_emails(self):
        """Send emails that are due"""
        current_time = datetime.now()
        
        for email in self.scheduled_emails[:]:
            if current_time >= email['send_time']:
                self.send_email(
                    email['to'],
                    email['subject'],
                    email['body']
                )
                self.scheduled_emails.remove(email)
    
    def send_email(self, to_email, subject, body):
        """Send email (implement your email sending logic)"""
        print(f"Sending email to {to_email}: {subject}")
        # Your email sending code here
    
    def run_scheduler(self):
        """Run the email scheduler"""
        schedule.every(1).minutes.do(self.send_scheduled_emails)
        
        while True:
            schedule.run_pending()
            time.sleep(60)

# Usage
scheduler = EmailScheduler()

# Schedule emails
scheduler.schedule_email(
    to_email='recipient@example.com',
    subject='Reminder',
    body='This is a reminder email.',
    send_time=datetime.now().replace(hour=9, minute=0, second=0, microsecond=0)
)

# Run scheduler
scheduler.run_scheduler()
```

## Email Parsing and Analysis

### Email Content Parsing

```python
import re
from bs4 import BeautifulSoup

class EmailParser:
    def __init__(self, email_content):
        self.email_content = email_content
        self.parsed_data = {}
    
    def parse_email(self):
        """Parse email content and extract information"""
        self.extract_headers()
        self.extract_body()
        self.extract_links()
        self.extract_phone_numbers()
        self.extract_emails()
        self.extract_dates()
        
        return self.parsed_data
    
    def extract_headers(self):
        """Extract email headers"""
        self.parsed_data['headers'] = {
            'subject': self.email_content.get('Subject', ''),
            'from': self.email_content.get('From', ''),
            'to': self.email_content.get('To', ''),
            'date': self.email_content.get('Date', ''),
            'cc': self.email_content.get('Cc', ''),
            'bcc': self.email_content.get('Bcc', '')
        }
    
    def extract_body(self):
        """Extract email body"""
        body = ""
        if self.email_content.is_multipart():
            for part in self.email_content.walk():
                if part.get_content_type() == "text/plain":
                    body = part.get_payload(decode=True).decode()
                    break
                elif part.get_content_type() == "text/html":
                    html_body = part.get_payload(decode=True).decode()
                    soup = BeautifulSoup(html_body, 'html.parser')
                    body = soup.get_text()
        else:
            body = self.email_content.get_payload(decode=True).decode()
        
        self.parsed_data['body'] = body
    
    def extract_links(self):
        """Extract links from email body"""
        body = self.parsed_data.get('body', '')
        link_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
        links = re.findall(link_pattern, body)
        self.parsed_data['links'] = links
    
    def extract_phone_numbers(self):
        """Extract phone numbers from email body"""
        body = self.parsed_data.get('body', '')
        phone_pattern = r'(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})'
        phone_numbers = re.findall(phone_pattern, body)
        self.parsed_data['phone_numbers'] = [''.join(phone) for phone in phone_numbers]
    
    def extract_emails(self):
        """Extract email addresses from email body"""
        body = self.parsed_data.get('body', '')
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, body)
        self.parsed_data['emails'] = emails
    
    def extract_dates(self):
        """Extract dates from email body"""
        body = self.parsed_data.get('body', '')
        date_pattern = r'\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b'
        dates = re.findall(date_pattern, body)
        self.parsed_data['dates'] = dates

# Usage
def parse_email_content(email_message):
    """Parse email content"""
    parser = EmailParser(email_message)
    parsed_data = parser.parse_email()
    
    print("Parsed Email Data:")
    print(f"Subject: {parsed_data['headers']['subject']}")
    print(f"From: {parsed_data['headers']['from']}")
    print(f"Body: {parsed_data['body'][:200]}...")
    print(f"Links: {parsed_data['links']}")
    print(f"Phone Numbers: {parsed_data['phone_numbers']}")
    print(f"Emails: {parsed_data['emails']}")
    print(f"Dates: {parsed_data['dates']}")
    
    return parsed_data
```

### Email Analytics

```python
import pandas as pd
from collections import Counter
import matplotlib.pyplot as plt

class EmailAnalytics:
    def __init__(self, emails_data):
        self.emails_data = emails_data
        self.df = pd.DataFrame(emails_data)
    
    def analyze_senders(self):
        """Analyze email senders"""
        sender_counts = self.df['from'].value_counts()
        return sender_counts.head(10)
    
    def analyze_subjects(self):
        """Analyze email subjects"""
        # Extract keywords from subjects
        all_subjects = ' '.join(self.df['subject'].fillna(''))
        words = re.findall(r'\b\w+\b', all_subjects.lower())
        word_counts = Counter(words)
        
        # Filter out common words
        common_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'}
        filtered_words = {word: count for word, count in word_counts.items() 
                         if word not in common_words and len(word) > 3}
        
        return Counter(filtered_words).most_common(10)
    
    def analyze_timeline(self):
        """Analyze email timeline"""
        self.df['date'] = pd.to_datetime(self.df['date'])
        self.df['hour'] = self.df['date'].dt.hour
        self.df['day_of_week'] = self.df['date'].dt.day_name()
        
        return {
            'hourly_distribution': self.df['hour'].value_counts().sort_index(),
            'daily_distribution': self.df['day_of_week'].value_counts()
        }
    
    def generate_report(self):
        """Generate email analytics report"""
        report = {
            'total_emails': len(self.df),
            'unique_senders': self.df['from'].nunique(),
            'top_senders': self.analyze_senders().to_dict(),
            'top_keywords': dict(self.analyze_subjects()),
            'timeline': self.analyze_timeline()
        }
        
        return report

# Usage
emails_data = [
    {'from': 'sender1@example.com', 'subject': 'Meeting tomorrow', 'date': '2023-01-01 10:00:00'},
    {'from': 'sender2@example.com', 'subject': 'Project update', 'date': '2023-01-01 14:00:00'},
    # ... more emails
]

analytics = EmailAnalytics(emails_data)
report = analytics.generate_report()
print(report)
```

## Best Practices

### 1. Security

```python
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Store credentials securely
EMAIL_USERNAME = os.getenv('EMAIL_USERNAME')
EMAIL_PASSWORD = os.getenv('EMAIL_PASSWORD')
SMTP_SERVER = os.getenv('SMTP_SERVER')
SMTP_PORT = int(os.getenv('SMTP_PORT', '587'))

# Use app passwords for Gmail
# Enable 2-factor authentication and generate app password
```

### 2. Error Handling

```python
import logging
from functools import wraps

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def handle_email_errors(func):
    """Decorator for email error handling"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except smtplib.SMTPAuthenticationError:
            logger.error("Email authentication failed")
        except smtplib.SMTPRecipientsRefused:
            logger.error("Email recipient refused")
        except smtplib.SMTPServerDisconnected:
            logger.error("SMTP server disconnected")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
        return None
    return wrapper

@handle_email_errors
def send_email_safe(to_email, subject, body):
    """Send email with error handling"""
    # Your email sending code here
    pass
```

### 3. Rate Limiting

```python
import time
from functools import wraps

def rate_limit(calls_per_minute):
    """Rate limiting decorator"""
    min_interval = 60.0 / calls_per_minute
    last_called = [0.0]
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            left_to_wait = min_interval - elapsed
            if left_to_wait > 0:
                time.sleep(left_to_wait)
            ret = func(*args, **kwargs)
            last_called[0] = time.time()
            return ret
        return wrapper
    return decorator

@rate_limit(10)  # 10 calls per minute
def send_email_rate_limited(to_email, subject, body):
    """Send email with rate limiting"""
    # Your email sending code here
    pass
```

## Conclusion

Python email automation can significantly improve productivity and communication efficiency. By following these patterns and best practices, you can create robust email automation solutions.

Remember to:
- Always handle errors gracefully
- Implement proper rate limiting
- Use secure authentication methods
- Monitor email delivery
- Follow email best practices
- Respect recipient preferences

Happy automating! 🚀
