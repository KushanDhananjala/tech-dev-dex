---
title: "Node.js Heroku Deployment: Complete Production Guide"
description: "Deploy Node.js applications to Heroku. Database setup, environment variables, scaling, and production optimization."
author: "TechDevDex Team"
date: "2024-12-11"
category: "Tutorial"
tags: ["Node.js", "Heroku", "Deployment", "Production", "Scaling"]
readTime: "24 min"
featured: false
rating: 5
featuredImage: "/images/tutorials/react-node-deployment/nodejs-heroku.svg"
---

# Node.js Heroku Deployment: Complete Production Guide

Learn how to deploy Node.js applications to Heroku with proper configuration, database setup, and production optimization.

## What is Heroku?

Heroku is a cloud platform that enables developers to build, run, and operate applications entirely in the cloud. It's particularly popular for Node.js applications due to its simplicity and ease of use.

### Key Features

- **Git-based Deployments**: Deploy directly from Git repositories
- **Add-ons**: Easy integration with databases and services
- **Scaling**: Horizontal and vertical scaling options
- **Monitoring**: Built-in logging and monitoring
- **SSL**: Automatic SSL certificate management

## Getting Started

### Prerequisites

- Heroku account
- Git repository with Node.js app
- Heroku CLI installed
- Node.js 18+ installed

### Install Heroku CLI

```bash
# macOS
brew tap heroku/brew && brew install heroku

# Windows
# Download from https://devcenter.heroku.com/articles/heroku-cli

# Linux
curl https://cli-assets.heroku.com/install.sh | sh

# Verify installation
heroku --version
```

### Login to Heroku

```bash
# Login to Heroku
heroku login

# Verify authentication
heroku auth:whoami
```

## Basic Setup

### Project Structure

```
my-node-app/
├── src/
│   ├── routes/
│   ├── models/
│   ├── middleware/
│   └── app.js
├── package.json
├── Procfile
├── .env
└── .gitignore
```

### Package.json Configuration

```json
{
  "name": "my-node-app",
  "version": "1.0.0",
  "description": "My Node.js application",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "build": "npm install"
  },
  "engines": {
    "node": "18.x",
    "npm": "8.x"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.2"
  }
}
```

### Procfile

```bash
# Procfile
web: node src/app.js
```

### Environment Variables

```bash
# .env
NODE_ENV=development
PORT=3000
DATABASE_URL=postgresql://user:password@localhost:5432/myapp
JWT_SECRET=your-jwt-secret
API_KEY=your-api-key
```

## Creating Heroku App

### Create App

```bash
# Create new Heroku app
heroku create my-node-app

# Or create with specific name
heroku create my-awesome-app

# Check app info
heroku info
```

### Git Integration

```bash
# Add Heroku remote
git remote add heroku https://git.heroku.com/my-node-app.git

# Deploy to Heroku
git push heroku main

# Check app status
heroku ps
```

## Database Setup

### PostgreSQL Add-on

```bash
# Add PostgreSQL add-on
heroku addons:create heroku-postgresql:mini

# Check database info
heroku pg:info

# Connect to database
heroku pg:psql
```

### Database Configuration

```javascript
// src/config/database.js
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

module.exports = pool;
```

### Database Migrations

```bash
# Install migration tool
npm install --save-dev db-migrate db-migrate-pg

# Create migration
db-migrate create create-users-table

# Run migrations
db-migrate up

# Rollback migration
db-migrate down
```

## Express.js Application

### Basic Express App

```javascript
// src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.get('/', (req, res) => {
  res.json({ message: 'Hello from Heroku!' });
});

app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### Advanced Express Configuration

```javascript
// src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');
require('dotenv').config();

const app = express();

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
app.use(limiter);

// Compression
app.use(compression());

// CORS
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
  credentials: true
}));

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Routes
app.use('/api', require('./routes'));

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  
  if (err.name === 'ValidationError') {
    return res.status(400).json({ error: err.message });
  }
  
  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  res.status(500).json({ error: 'Internal server error' });
});

module.exports = app;
```

## Environment Variables

### Setting Environment Variables

```bash
# Set environment variables
heroku config:set NODE_ENV=production
heroku config:set JWT_SECRET=your-secret-key
heroku config:set API_KEY=your-api-key

# View all environment variables
heroku config

# Get specific variable
heroku config:get NODE_ENV

# Remove environment variable
heroku config:unset API_KEY
```

### Using Environment Variables

```javascript
// src/config/index.js
module.exports = {
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL,
  jwtSecret: process.env.JWT_SECRET,
  apiKey: process.env.API_KEY,
  allowedOrigins: process.env.ALLOWED_ORIGINS?.split(',') || ['*'],
  isProduction: process.env.NODE_ENV === 'production',
  isDevelopment: process.env.NODE_ENV === 'development'
};
```

## Database Integration

### PostgreSQL with Prisma

```javascript
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### Database Service

```javascript
// src/services/database.js
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

class DatabaseService {
  async createUser(userData) {
    return await prisma.user.create({
      data: userData
    });
  }

  async getUserById(id) {
    return await prisma.user.findUnique({
      where: { id }
    });
  }

  async updateUser(id, userData) {
    return await prisma.user.update({
      where: { id },
      data: userData
    });
  }

  async deleteUser(id) {
    return await prisma.user.delete({
      where: { id }
    });
  }
}

module.exports = new DatabaseService();
```

## API Routes

### User Routes

```javascript
// src/routes/users.js
const express = require('express');
const router = express.Router();
const databaseService = require('../services/database');
const { validateUser } = require('../middleware/validation');

// GET /api/users
router.get('/', async (req, res) => {
  try {
    const users = await databaseService.getAllUsers();
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// POST /api/users
router.post('/', validateUser, async (req, res) => {
  try {
    const user = await databaseService.createUser(req.body);
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
});

// GET /api/users/:id
router.get('/:id', async (req, res) => {
  try {
    const user = await databaseService.getUserById(req.params.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

module.exports = router;
```

### Authentication Routes

```javascript
// src/routes/auth.js
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const router = express.Router();

// POST /api/auth/login
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user by email
    const user = await databaseService.getUserByEmail(email);
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Check password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate JWT token
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({ token, user: { id: user.id, email: user.email } });
  } catch (error) {
    res.status(500).json({ error: 'Login failed' });
  }
});

module.exports = router;
```

## Scaling and Performance

### Horizontal Scaling

```bash
# Scale web dynos
heroku ps:scale web=2

# Scale worker dynos
heroku ps:scale worker=1

# Check dyno status
heroku ps

# Restart all dynos
heroku restart
```

### Performance Optimization

```javascript
// src/middleware/cache.js
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 }); // 10 minutes

const cacheMiddleware = (duration = 600) => {
  return (req, res, next) => {
    const key = req.originalUrl;
    const cachedResponse = cache.get(key);
    
    if (cachedResponse) {
      return res.json(cachedResponse);
    }
    
    res.sendResponse = res.json;
    res.json = (body) => {
      cache.set(key, body, duration);
      res.sendResponse(body);
    };
    
    next();
  };
};

module.exports = cacheMiddleware;
```

### Database Connection Pooling

```javascript
// src/config/database.js
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
  max: 20, // Maximum number of clients in the pool
  idleTimeoutMillis: 30000, // Close idle clients after 30 seconds
  connectionTimeoutMillis: 2000, // Return an error after 2 seconds if connection could not be established
});

module.exports = pool;
```

## Monitoring and Logging

### Application Logs

```bash
# View logs
heroku logs --tail

# View specific number of lines
heroku logs --tail -n 100

# View logs from specific dyno
heroku logs --tail --dyno web.1
```

### Custom Logging

```javascript
// src/utils/logger.js
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'my-node-app' },
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

module.exports = logger;
```

### Health Checks

```javascript
// src/routes/health.js
const express = require('express');
const router = express.Router();

router.get('/', async (req, res) => {
  try {
    // Check database connection
    await databaseService.healthCheck();
    
    res.json({
      status: 'OK',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      version: process.env.npm_package_version || '1.0.0'
    });
  } catch (error) {
    res.status(503).json({
      status: 'ERROR',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

module.exports = router;
```

## CI/CD Pipeline

### GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy to Heroku

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm test
      
    - name: Deploy to Heroku
      uses: akhileshns/heroku-deploy@v3.12.12
      with:
        heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
        heroku_app_name: "my-node-app"
        heroku_email: "your-email@example.com"
        appdir: "."
```

## Troubleshooting

### Common Issues

1. **Build Failures**
   ```bash
   # Check build logs
   heroku logs --tail
   
   # Check buildpack
   heroku buildpacks
   ```

2. **Database Connection Issues**
   ```bash
   # Check database status
   heroku pg:info
   
   # Reset database
   heroku pg:reset DATABASE_URL
   ```

3. **Memory Issues**
   ```bash
   # Check memory usage
   heroku ps:scale web=1
   
   # Upgrade dyno type
   heroku ps:scale web=1:standard-1x
   ```

### Debugging Commands

```bash
# Run one-off dyno
heroku run bash

# Check environment variables
heroku config

# Check app status
heroku ps:scale

# View app info
heroku info
```

## Best Practices

### 1. Security

- Use environment variables for secrets
- Implement rate limiting
- Use HTTPS
- Validate input data
- Implement proper authentication

### 2. Performance

- Use connection pooling
- Implement caching
- Optimize database queries
- Use compression
- Monitor performance metrics

### 3. Monitoring

- Set up logging
- Monitor application health
- Use error tracking
- Monitor database performance

### 4. Scaling

- Use horizontal scaling
- Implement load balancing
- Monitor resource usage
- Plan for traffic spikes

## Conclusion

Heroku provides an excellent platform for deploying Node.js applications with minimal configuration. By following these best practices and implementing proper monitoring, you can create robust, scalable applications.

Remember to:
- Use environment variables for configuration
- Implement proper error handling
- Monitor application performance
- Follow security best practices
- Plan for scaling

Happy deploying! 🚀
